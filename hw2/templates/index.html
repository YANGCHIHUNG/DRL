<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Grid Map with Value Iteration</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,500&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
      margin: 0;
      padding: 20px;
      color: #333;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .container {
      max-width: 960px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .instruction {
      margin-bottom: 20px;
      font-size: 16px;
      line-height: 1.5;
    }
    .instruction ul {
      list-style: none;
      padding: 0;
    }
    .instruction li {
      margin-bottom: 10px;
      padding-left: 20px;
      position: relative;
    }
    .instruction li:before {
      content: "✔";
      position: absolute;
      left: 0;
      color: #4caf50;
    }
    form {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    input[type="number"] {
      width: 60px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 16px;
    }
    button {
      padding: 8px 16px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #2196f3;
      color: white;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #1976d2;
    }
    table {
      margin: 0 auto;
      border-collapse: collapse;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    td {
      width: 60px;
      height: 60px;
      border: 1px solid #ddd;
      text-align: center;
      vertical-align: middle;
      cursor: pointer;
      font-size: 16px;
      position: relative;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
    td:hover {
      transform: scale(1.05);
    }
    /* Colors for start, end, and obstacles */
    .start { background-color: #4caf50; color: white; }
    .end { background-color: #f44336; color: white; }
    .obstacle { background-color: #9e9e9e; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Grid Map with Value Iteration</h1>
    <!-- 操作說明 -->
    <div class="instruction">
      <p><strong>操作說明：</strong></p>
      <ul>
        <li>設定網格尺寸（5 至 9），然後按「Create Grid」。</li>
        <li>點擊任一單元格：第一個點選的會變成<strong>起點</strong>（綠色），第二個會變成<strong>終點</strong>（紅色）。</li>
        <li>接下來點選最多 n-2 個單元格作為<strong>障礙物</strong>（灰色）。</li>
        <li>點擊「Compute Optimal Policy and Value」按鈕以運行價值迭代算法。</li>
        <li>每個單元格會顯示最佳行動（箭頭）和狀態價值 V(s)。</li>
        <li>系統將以動畫方式展示從起點到終點的最佳路徑（起點與終點除外）。</li>
        <li>如需重新設定，請點擊「Reset」。</li>
      </ul>
    </div>
  
    <!-- 設定網格尺寸 -->
    <form method="post" action="/">
      <label for="grid_size">網格尺寸 (5-9): </label>
      <input type="number" name="grid_size" id="grid_size" value="{{ n }}" min="5" max="9">
      <button type="submit">Create Grid</button>
      <button type="button" onclick="resetGrid()">Reset</button>
    </form>
  
    <!-- 價值迭代功能按鈕 -->
    <div style="text-align: center; margin-bottom: 20px;">
      <button type="button" onclick="computeOptimalPolicyAndValue()">Compute Optimal Policy and Value</button>
    </div>
  
    <!-- 根據 n 動態生成網格 -->
    <table id="grid">
      {% for i in range(n) %}
        <tr>
          {% for j in range(n) %}
            <td id="cell_{{ i }}_{{ j }}" onclick="cellClicked({{ i }}, {{ j }})"></td>
          {% endfor %}
        </tr>
      {% endfor %}
    </table>
  </div>
  
  <script>
    let n = {{ n }};
    let startSet = false;
    let endSet = false;
    let obstacleCount = 0;
    let maxObstacles = n - 2;
    let startCoord = null;
    let endCoord = null;
    let actions = ["↑", "↓", "←", "→"];

    function cellClicked(row, col) {
      let cell = document.getElementById("cell_" + row + "_" + col);
      if (cell.classList.contains("start") || cell.classList.contains("end") || cell.classList.contains("obstacle")) {
        return;
      }
      if (!startSet) {
        cell.classList.add("start");
        startSet = true;
        startCoord = [row, col];
      } else if (!endSet) {
        cell.classList.add("end");
        endSet = true;
        endCoord = [row, col];
      } else if (obstacleCount < maxObstacles) {
        cell.classList.add("obstacle");
        obstacleCount++;
      }
    }

    function resetGrid(){
      const cells = document.querySelectorAll("td");
      cells.forEach(cell => {
        cell.classList.remove("start", "end", "obstacle");
        cell.style.backgroundColor = "";
        cell.innerHTML = "";
      });
      startSet = false;
      endSet = false;
      obstacleCount = 0;
      startCoord = null;
      endCoord = null;
    }

    function animatePath(path) {
      let delay = 300;
      path.forEach((coord, index) => {
        setTimeout(() => {
          let cell = document.getElementById("cell_" + coord[0] + "_" + coord[1]);
          if (!cell.classList.contains("start") && !cell.classList.contains("end")) {
            cell.style.backgroundColor = "lightgreen";
          }
        }, delay * index);
      });
    }

    function computeOptimalPolicyAndValue() {
      let V = new Array(n);
      let optimalPolicy = new Array(n);
      for (let i = 0; i < n; i++) {
        V[i] = new Array(n);
        optimalPolicy[i] = new Array(n);
        for (let j = 0; j < n; j++) {
          let cell = document.getElementById("cell_" + i + "_" + j);
          if (cell.classList.contains("obstacle")) {
            V[i][j] = null;
            optimalPolicy[i][j] = "";
          } else {
            V[i][j] = 0;
            optimalPolicy[i][j] = "";
          }
        }
      }
      
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          let cell = document.getElementById("cell_" + i + "_" + j);
          if (cell.classList.contains("end")) {
            V[i][j] = 0;
          }
        }
      }
      
      let gamma = 0.9;
      let iterations = 100;
      
      for (let iter = 0; iter < iterations; iter++) {
        let newV = [];
        for (let i = 0; i < n; i++) {
          newV[i] = [];
          for (let j = 0; j < n; j++) {
            newV[i][j] = V[i][j];
          }
        }
        
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            let cell = document.getElementById("cell_" + i + "_" + j);
            if (cell.classList.contains("obstacle") || cell.classList.contains("end")) continue;
            let validActions = [];
            for (let a of actions) {
              let next_i = i, next_j = j;
              if (a === "↑") next_i = i - 1;
              else if (a === "↓") next_i = i + 1;
              else if (a === "←") next_j = j - 1;
              else if (a === "→") next_j = j + 1;
              if (next_i < 0 || next_i >= n || next_j < 0 || next_j >= n) continue;
              let nextCell = document.getElementById("cell_" + next_i + "_" + next_j);
              if (nextCell && nextCell.classList.contains("obstacle")) continue;
              validActions.push({action: a, next_i: next_i, next_j: next_j});
            }
            if (validActions.length === 0) {
              newV[i][j] = -1 + gamma * V[i][j];
              optimalPolicy[i][j] = "";
            } else {
              let bestValue = -Infinity;
              let bestAction = "";
              for (let option of validActions) {
                let qValue = -1 + gamma * V[option.next_i][option.next_j];
                if (qValue > bestValue) {
                  bestValue = qValue;
                  bestAction = option.action;
                }
              }
              newV[i][j] = bestValue;
              optimalPolicy[i][j] = bestAction;
            }
          }
        }
        V = newV;
      }
      
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          let cell = document.getElementById("cell_" + i + "_" + j);
          if (cell.classList.contains("obstacle")) continue;
          let displayAction = optimalPolicy[i][j] || "";
          let displayValue = (V[i][j] !== null && V[i][j] !== undefined) ? V[i][j].toFixed(1) : "";
          cell.innerHTML = displayAction + "<br>" + displayValue;
        }
      }
      
      if (startCoord && endCoord) {
        let path = [];
        let current = startCoord;
        let maxSteps = n * n;
        for (let step = 0; step < maxSteps; step++) {
          path.push(current);
          if (current[0] === endCoord[0] && current[1] === endCoord[1]) break;
          let action = optimalPolicy[current[0]][current[1]];
          if (!action) break;
          let next = [current[0], current[1]];
          if (action === "↑") next[0] = current[0] - 1;
          else if (action === "↓") next[0] = current[0] + 1;
          else if (action === "←") next[1] = current[1] - 1;
          else if (action === "→") next[1] = current[1] + 1;
          if (next[0] === current[0] && next[1] === current[1]) break;
          current = next;
        }
        animatePath(path);
      }
    }
  </script>
</body>
</html>
